#!/bin/bash
#
# -*-coding:iso-8859-15;-*-
#
# Modified: Sat Jul 17 11:21:48 2010
#
# Environnement bash pour la gestion de conf.
#

set -a

# Options
scm_env_o_git=1 # enable git
scm_env_o_svn=0 # disable svn
scm_env_e_readlink=0 # use readlink ?
scm_env_e_realpath=0 # use realpath ? (priority)

# Requirements
REALPATH=$(which realpath) && scm_env_e_realpath=1
if [ $scm_env_e_realpath -ne 1 ] ; then
	case $(uname -s) in
	    # require GNU coreutils (with ports / fink)
		# if "which" succeed then we know that we can use "readlink"
	    Darwin) READLINK=$(which greadlink) && scm_env_e_readlink=1 ;;
	    *) READLINK=$(which readlink) && scm_env_e_readlink=1 ;;
	esac
fi

    # uid=>couleur
    # user@host {status}
    # scm=>
    # oui     repo|br subdir
    # non     dir
    # $

promptF_COLORS=( "\[\033[0;32m\]" "\[\033[0;36m\]" "\[\033[0;35m\]" )
promptF_NO_COLOR="\[\033[0m\]"
promptF_RED="\[\033[0;31m\]"
promptF_BOLD="\[\033[1m\]"
promptF_defcolor=${promptF_COLORS[2]}
promptF_status="uninitialized"
promptF_scm_status=""
promptF_enable_titlebar=1

function promptF_color() {
    case $USER in
	root) return 1;;
	michel) return 2;;
	*) return 3;;
    esac
}
# export -f promptF_color

function promptF_setup() {
    local c
    promptF_color
    c=$?
    promptF_defcolor=${promptF_COLORS[$c]}
    promptF_status="setup"

    # only set titlebar in a capable terminal:
    case $TERM in
	rxvt*|xterm*|gnome*|konsole*)
	    promptF_enable_titlebar=0
            ;;
    esac
    export PROMPT_COMMAND="promptF_update"
}
# export -f promptF_setup

function promptF_update() {
    local titlebar
#    promptF_curdir
    if promptF_under_scm ; then
	promptF_status=" ${promptF_BOLD}$promptF_scm_status${promptF_defcolor}"
    else
	promptF_status=""
    fi
    if [ $promptF_enable_titlebar -eq 0 ] ; then
        titlebar="\033]2;${USER}@${HOSTNAME} $promptF_scm_status\007"
	# since we are in PROMPT_COMMAND callback, 
	# let's write directly to stdout
	echo -ne $titlebar
    fi
    export PS1="${promptF_defcolor}\u@\h${promptF_status} \w \$ $promptF_NO_COLOR"
}
# export -f promptF_update

# fonction désactivée: trouver mieux!
function promptF_curdir() {
    local cwd
    if [ ${#PWD} -gt 20 ] ; then
	cwd="...${PWD:10}"
    else
	cwd=${PWD}
    fi 
    promptF_PWD=$cwd
}
# export -f promptF_curdir

# à étendre en fonction des différents scm
function promptF_under_scm() {
    if promptF_scm_check_CVS ; then
	return 0
    elif promptF_scm_check_SVN ; then
	return 0
    elif promptF_scm_check_GIT ; then
	return 0
    else
	return 1
    fi
}
# export -f promptF_under_scm

function promptF_scm_check_CVS {
    if [ -d "CVS" ] ; then
	promptF_scm_status="in CVS wk"
	return 0
    fi
    return 1
}
# export -f promptF_scm_check_CVS

function promptF_scm_check_SVN {
    if [ -d ".svn" ] ; then
	promptF_scm_status="in SVN wk"
	return 0
    fi
    return 1
}
# export -f promptF_scm_check_SVN

function __absolute_dir {
    if [ $scm_env_e_realpath -eq 1 ] ; then
	$REALPATH "$1"
    elif [ $scm_env_e_readlink -eq 1 ] ; then
	$READLINK -f "$1"
    else
	echo "$1"
    fi
}

# arg: #1: starting path for search
function _scm_find_git_dir {
    local dir=${1:-$PWD}
    local r=0

    # check environment first
    if [ ! -z "$GIT_DIR" ] ; then
	if [ -d "$GIT_DIR" ] ; then
	    dir=$(__absolute_dir "$GIT_DIR")
	else
	    # error: $GIT_DIR points to non-existing directory
	    dir=""
	    r=1
	fi
    else
	until [ "$dir" -ef / ]; do
	    if [ -d "$dir/.git" ]; then
		dir=$(__absolute_dir "$dir")
		break
	    fi
            dir=$(__absolute_dir "${dir}/..")
	done
    fi
    echo "$dir"
    return $r
}
export -f _scm_find_git_dir

# argument requis: chemin de la repository
function _scm_find_git_branch {
    local dir=
    local git_branch=
    local head=

    dir=${1:?"_scm_find_git_branch() requires 1 argument: repository path"}
    if [ -f "$dir/.git/HEAD" ]; then
	head=$(< "$dir/.git/HEAD")
	if [[ $head == ref:\ refs/heads/* ]]; then
	    git_branch="${head#*/*/}"
	elif [[ $head != '' ]]; then
	    git_branch='(detached)'
	else
	    git_branch='(unknown)'
	fi
	echo $git_branch
	return 0
    fi
    echo ""
    return 1
}
export -f _scm_find_git_branch

function promptF_scm_check_GIT {
    local git_branch=
    local git_repo=
    local dir=$(_scm_find_git_dir)

    if [ $? -ne 0 ] ; then
	promptF_scm_status=""
	return 1
    fi
    git_repo=${dir##*/}
    # on peut encore avoir une chaine vide ici
    if [ -z "$git_repo" ] ; then
	promptF_scm_status=""
	return 1
    fi

    # il faut encore récupérer la branche courante
    git_branch=$(_scm_find_git_branch "$dir")
    if [ $? -ne 0 ] ; then
	promptF_scm_status=""
	return 1
    fi
    promptF_scm_status="[${git_repo}] _${git_branch}_"
    return 0
}
# export -f promptF_scm_check_GIT

echo "Setup scm (cvs/svn/git) extended prompt"
promptF_setup

# ??? pas de completion pour CVS sur Debian ???

# Completion Bash pour Git
if [ $scm_env_o_git -eq 1 ] ; then
	# sur Debian
	[ -f /etc/bash_completion.d/git ] && \
		. /etc/bash_completion.d/git
	# sur Mac OSX (avec Mac Ports)
	[ -f /opt/local/share/doc/git-core/contrib/completion/git-completion.bash ] && \
		. /opt/local/share/doc/git-core/contrib/completion/git-completion.bash
fi

# Completion Bash pour Subversion
if [ $scm_env_o_svn -eq 1 ] ; then
	# sur Debian
	[ -f /etc/bash_completion.d/subversion ] && . /etc/bash_completion.d/subversion
	# sur Mac OSX (?)
fi

set +a

