#!/bin/bash
#
# -*-coding:iso-8859-15;-*-
#
# Modified: Tue Jul 27 02:56:36 2010
#
# Environnement bash pour la gestion de configuration.
# Bash environment for configuration management.
#
# Copyright (C) 2009, 2010 Michel Briand.
#
# This file is released under the GNU GPL license.
#

# Booleans

TRUE=0
FALSE=1
ENABLED=1
DISABLED=0

export TRUE FALSE ENABLED DISABLED

# NB: Christophe, Éric, ... peut être pensez-vous que je cherche
#     des poils sur les oeufs avec ces booléens... Si vous avez
#     envie de simplifier tout ça, n'hésitez pas à me proposer
#     quelque chose...

# Options
if [ -z "$scm_env_o_debug" ] ; then
    # if already defined in environment, do nothing
    scm_env_o_debug=$DISABLED # disable debug by default
fi
scm_env_o_git=$ENABLED # enable git by default
scm_env_o_svn=$DISABLED # disable svn by default
scm_env_e_readlink=$DISABLED # use readlink ? will 'require' it
scm_env_e_realpath=$DISABLED # use realpath ? will 'require' it
scm_env_e_titlebar=$DISABLED # we check for xterm in setup

# Debug function

shopt -s expand_aliases
alias ifD='[ $scm_env_o_debug -eq $ENABLED ] && '

# it's really important to have an echo-like function that
# do not alter stdout because many functions are expecting
# a return value through stdout

echoD()
{
    ifD echo "$*" >&2
}
export -f echoD

ifD set -x

# Requirements

# require fonction will check for a command availability
# in PATH and return its status either basically ($?) or
# in a status variable (if given)

require() #1: command #2(opt): status variable (ENABLED/DISABLED)
{
    local tmp=
    local cmd="${1?-'require(): argument required: command name'}"
    local var_cmd="$2"
    local var="$3"
    local status=$DISABLED

    # check for command with 'which'
    tmp=$(which "$1")
    if [ $? -eq 0 ] ; then
	status=$ENABLED
    else
	# in case this does not work, check with 'type' (HP, Sun)
	tmp=$(type -p "$1")
	if [ $? -eq 0 ] ; then
	    status=$ENABLED
	fi
    fi

    # check for command executable bit
    if [ $status -eq $ENABLED ] ; then
	if [ ! -x "$tmp" ] ; then
	    echoD "require: command was found but is not executable: $cmd"
	    status=$DISABLED
	fi
    fi

    # check if we were called with only one argument
    if [ -z "$var_cmd" ] ; then
	# yes: simply return status
	return $status
    else
	# at least a variable to store the path of command in
	eval "$var_cmd=$tmp"
	# check if we were called with three arguments
	if [ -z "$var" ] ; then
	    # return status basically
	    return $status
	else
	    # return status through a variable
	    eval "$var=$status"
	    return $status
	fi
    fi
}
export -f require

# Maintenant, avec la fonction require(), on peut écrire la ligne
#   REALPATH=$(which realpath) && scm_env_e_realpath=1
# comme ceci:
require realpath REALPATH scm_env_e_realpath

# De la même manière on peut ré-écrire les lignes suivantes
#   if [ $scm_env_e_realpath -ne 1 ] ; then
#   	case $(uname -s) in
#	    # require GNU coreutils (with ports / fink)
#		# if "which" succeed then we know that we can use "readlink"
#	    Darwin) READLINK=$(which greadlink) && scm_env_e_readlink=1 ;;
#	    *) READLINK=$(which readlink) && scm_env_e_readlink=1 ;;
#	esac
#   fi
# comme ceci:
scm_platform=$(uname -s)
case $scm_platform in
    Darwin) require greadlink READLINK scm_env_e_readlink ;;
    Linux) require readlink READLINK scm_env_e_readlink ;;
    *) echo "Platform not supported: $scm_platform"; return 1 ;;
esac

    # uid=>couleur
    # user@host {status}
    # scm=>
    # oui     repo|br subdir
    # non     dir
    # $

echoD "=== debug require ==="
echoD "scm_env_e_realpath=$scm_env_e_realpath $REALPATH"
echoD "scm_env_e_readlink=$scm_env_e_readlink $READLINK"
echoD

scm_COLORS=( "\033[0;32m" "\033[0;36m" "\033[0;35m" )
scm_NO_COLOR="\033[0m"
scm_RED="\033[0;31m"
scm_GREEN="\033[0;32m"
scm_YELLOW="\033[0;33m"
scm_BOLD="\033[1m"
scm_defcolor=${scm_COLORS[2]}
scm_prompt_status="uninitialized"
scm_scm_status=
scm_cwd=

scm_user_color() 
{
    case $USER in
	root) return 1;;
	michel) return 2;;
	*) return 3;;
    esac
}
export -f scm_user_color

scm_prompt_setup()
{
    local c
    scm_user_color
    c=$?
    scm_defcolor=${scm_COLORS[$c]}
    scm_prompt_status="setup"
    # only set titlebar in a capable terminal:
    case $TERM in
	rxvt*|xterm*|gnome*|konsole*)
	    scm_env_e_titlebar=$ENABLED
            ;;
    esac
    export PROMPT_COMMAND="scm_prompt_update"
}
export -f scm_prompt_setup

scm_prompt_update()
{
    scm_curdir
    if scm_under_scm ; then
	scm_prompt_status="${scm_BOLD}$scm_scm_status${scm_defcolor}"
    else
	scm_prompt_status=""
    fi
    if [ $scm_env_e_titlebar -eq $ENABLED ] ; then
	# since we are in PROMPT_COMMAND callback, 
	# let's write directly to stdout
        echo -ne "\033]0;\007\033]2;${USER}@${HOSTNAME%%.*} $scm_cwd $scm_scm_status\007"
    fi
    export PS1="${scm_defcolor}\u@\h ${scm_prompt_status} $scm_cwd \\$ $scm_NO_COLOR"
}
export -f scm_prompt_update

scm_curdir()
{
    local cwd
    if [ "$PWD" -ef "$HOME" ] ; then
	cwd='~'
    else
	cwd=${PWD/$HOME\//'~'/}
	if [ ${#cwd} -gt 20 ] ; then
	    cwd="...${cwd:10}"
	fi
    fi
    scm_cwd=$cwd
}
export -f scm_curdir

# to complete with other SCM tools

scm_under_scm()
{
    if scm_check_CVS ; then
	return 0
    elif scm_check_SVN ; then
	return 0
    elif scm_check_GIT ; then
	return 0
    else
	return 1
    fi
}
export -f scm_under_scm

scm_check_CVS()
{
    if [ -d "CVS" ] ; then
	scm_scm_status="in CVS wk"
	return 0
    fi
    return 1
}
export -f scm_check_CVS

scm_check_SVN()
{
    if [ -d ".svn" ] ; then
	scm_scm_status="in SVN wk"
	return 0
    fi
    return 1
}
export -f scm_check_SVN

scm_absdir() #1: path
{
    echoD "scm_absdir: $1"
    if [ $scm_env_e_realpath -eq 1 ] ; then
	$REALPATH "$1"
    elif [ $scm_env_e_readlink -eq 1 ] ; then
	$READLINK -f "$1"
    else
	# no way to make this dir absolue...
	# no-op
	echo "$1" # return value
    fi
}
export -f scm_absdir

scm_find_git_dir() #1: starting path for search
{
    local dir=${1:-$PWD}
    local r=$TRUE

    echoD "debug _scm_find_git_dir: starting at $dir"

    # check environment first
    if [ ! -z "$GIT_DIR" ] ; then
	if [ -d "$GIT_DIR" ] ; then
	    dir=$(scm_absdir "$GIT_DIR")
	else
	    # error: $GIT_DIR points to non-existing directory
	    dir=""
	    r=$FALSE
	fi
    else
	echoD "sfgd1: $dir"
	until [ "$dir" -ef / ]; do
	    if [ -d "$dir/.git" ]; then
		dir=$(scm_absdir "$dir")
		break
	    fi
            dir=$(scm_absdir "${dir}/..")
	    echoD "sfgd2: $dir"
	done
    fi
    echo "$dir" # return value
    return $r
}
export -f scm_find_git_dir

scm_find_git_branch() #1: repository path
{
    local dir=
    local branch=
    local head=

    dir=${1:?"scm_find_git_branch() requires 1 argument: repository path"}
    if [ -f "$dir/.git/HEAD" ]; then
	head=$(< "$dir/.git/HEAD")
	if [[ $head == ref:\ refs/heads/* ]]; then
	    branch="${head#*/*/}"
	elif [[ $head != '' ]]; then
	    branch='(detached)'
	else
	    branch='(unknown)'
	fi
	echo $branch # return value
	return $TRUE
    fi
    echo "" # return value
    return $FALSE
}
export -f scm_find_git_branch

scm_check_GIT()
{
    local branch=
    local repo=
    local dir=$(scm_find_git_dir)

    if [ $? -ne 0 ] ; then
	scm_scm_status=""
	return $FALSE
    fi
    repo=${dir##*/}
    # we can still have an empty string here
    if [ -z "$repo" ] ; then
	scm_scm_status=""
	return $FALSE
    fi

    # pick up the current branch
    branch=$(scm_find_git_branch "$dir")
    if [ $? -ne 0 ] ; then
	scm_scm_status=""
	return $FALSE
    fi
    scm_scm_status="[${repo}] _${branch}_"
    return $TRUE
}
export -f scm_check_GIT

ifD echo "Setup scm (cvs/svn/git) extended prompt"
scm_prompt_setup

# ??? pas de completion pour CVS sur Debian ???

# Completion Bash pour Git
if [ $scm_env_o_git -eq $ENABLED ] ; then
    # sur Debian
    [ -f /etc/bash_completion.d/git ] && \
	. /etc/bash_completion.d/git
    # sur Mac OSX (avec Mac Ports)
    [ -f /opt/local/share/doc/git-core/contrib/completion/git-completion.bash ] && \
	. /opt/local/share/doc/git-core/contrib/completion/git-completion.bash
fi

# Completion Bash pour Subversion
if [ $scm_env_o_svn -eq $ENABLED ] ; then
    # sur Debian
    [ -f /etc/bash_completion.d/subversion ] && \
	. /etc/bash_completion.d/subversion
    # sur Mac OSX (?)
fi
