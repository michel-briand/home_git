#!/bin/bash
#
# -*-coding:iso-8859-15;-*-
#
# Gérer certains fichiers de la $HOME avec Git.

set -a

# =======================================
oV=0
oD=0
sS=0
# Bash booleans (opposite of usual logic)
TRUE=0
FALSE=1
# Ebool = enabled/disabled boolean values
ENABLED=1
DISABLED=0
# condition "if verbose"
alias ifV='[ $oV -eq $ENABLED ] && '
# condition "if debug"
alias ifD='[ $oD -eq $ENABLED ] && '
#
shopt -s expand_aliases
# =======================================

if [ -z "$o_scm" ] ; then
    o_scm=$DISABLED
fi

# SUPPPORT scm_env
case $o_scm in
    $ENABLED)
	if $(which scm_env 2>&1 >/dev/null) ; then
	    # le support de scm_env est activé: le but est
	    # de modifier le PS1 en fonction du statut et
	    # des actions...
	    . scm_env
	fi
	;;
    *) ;;
esac

# REQUIRE POSIX TOOLS / GNU coreutils
u=$(id -un)

# DISPLAY FUNCTION
home_git_em_color="\033[0;31m"
home_git_df_color="\033[0m"
export home_git_em_color home_git_df_color

echo_em() {
    # TODO: trouver un meilleur moyen de détecter
    # un terminal capable d'afficher des couleurs.
    # En tout cas on veut qu'à travers un pipe il
    # n'y ait pas de couleur.
    case "$TERM" in
	linux|xterm)
	    echo -e "${home_git_em_color}$*${home_git_df_color}"
	    ;;
	*)
	    echo "$*"
	    ;;
    esac
}
export -f echo_em

HOME_GIT_DIR="$HOME/.git_home_${u}"
HOME_GIT_WORK_TREE="$HOME"

#
# Wrapper pour git dans notre environnement "home utilisateur"
#
home_git_git() {
    [ -z "$*" ] && {
	echo "Ceci est un alias pour git avec pour environnement:"
	echo "GIT_DIR=$HOME_GIT_DIR"
	echo "GIT_WORK_TREE=$HOME_GIT_WORK_TREE"
	return 0
    }
    # gestion de less avec git : à travailler !!!
    PAGER= git --git-dir="$HOME_GIT_DIR" \
	--work-tree="$HOME_GIT_WORK_TREE" "$@" 
}
export -f home_git_git

#
# Wrapper pour gitk
#
home_git_gitk() {
    GIT_DIR="$HOME_GIT_DIR" \
	GIT_WORK_TREE="$HOME_GIT_WORK_TREE" \
	gitk "$@" 
}
export -f home_git_gitk

#
# Pour l'instant la configuration contient une variable
# nommée 'home_git_peers' qui défini l'embryon du réseau
# de pairs.
#
home_git_load_conf() {
    if [ -f "$HOME/.home_git" ] ; then
	. "$HOME/.home_git"
    else
	ifV echo "No configuration file found (~/.home_git)."
    fi
}
export -f home_git_load_conf

#
# Liste les fichiers gérés
#
home_git_list_managed() {
    home_git_git ls-files --full-name -t
}
export -f home_git_list_managed

#
# TODO: Ajouter un fichier
#
home_git_add() {
    home_git_git add -- $@
}
export -f home_git_add

#
# simple statut: list le delta entre l'état actuel
# et le dépôt git (index)
#
home_git_status() {
    home_git_git diff --stat $@
}
export -f home_git_status

#
# Liste les fichiers par genre: 'cached' (fichiers à jour),
# 'removed', 'modified', 'created'. 
# Ici on ignore les 'others' car les fichiers non gérés 
# ne doivent pas géner la sortie.
#
home_git_status_ex() {
    # récupère le statut
    cd "$HOME_GIT_WORK_TREE"
    sCached=$(home_git_git ls-files --cached)
    sDeleted=$(home_git_git ls-files --deleted)
    sModified=$(home_git_git ls-files --modified)
    cd - > /dev/null
    # affiche le statut
    ifV echo_em "= HG current directory status ="
    if [ ! -z "$sCached" ] ; then
	echo_em "== Up-to-date =="
	echo "$sCached" # <-- if variable is not quoted
    fi
    if [ ! -z "$sDeleted" ] ; then
	echo_em "== Removed =="  #     we lose trailing newlines
	echo "$sDeleted"
    fi
    if [ ! -z "$sModified" ] ; then
	echo_em "== Modified =="
	echo "$sModified"
    fi
    return 0
}
export home_git_status_ex

home_git_list_peers() {
    # fichier de configuration
    home_git_load_conf
    echo "HG peers: $home_git_peers"
}
export -f home_git_list_peers

home_git_sync_peer() { #1: peer remote name
    local p=$1
    if [ -z "$p" ] ; then
	echo "Required argument: peer name"
	return 1
    fi
    ifV echo_em "HG synching peer $p..."
    home_git_git fetch $p
    home_git_git diff --stat $p
}
export -f home_git_sync_peer

home_git_sync_all_peers() {
    for p in $home_git_peers ; do
	home_git_sync_peer $p
    done
}
export -f home_git_sync_all_peers

#
# Ajoute et commite les fichiers en argument
home_git_add_and_commit() {
    # pour éviter toute erreur d'argument, on impose
    # que ce soit 1 ou plusieurs fichiers qui existent
    local i f
    if [ $# -lt 1 ] ; then
	echo "HG: requière au moins un argument"
	return
    fi
    for i in $(seq 1 $#) ; do
	eval f=\$$i
	if [ ! -f "$f" ] ; then
	    echo "HG: requière des fichiers en argument"
	    return
	fi
    done
    home_git_git add $@
    home_git_git commit -v
}
export -f home_git_add_and_commit
#


alias HG=home_git_git             # commande "principale"
alias HGL=home_git_list_managed   # liste des fichiers gérés
alias HGS=home_git_status         # le plus utile
alias HGSF=home_git_status_ex     # statut perso (pas très utile)
alias HGK=home_git_gitk           # vue graphique

alias HGD='home_git_status -p'	# différences
alias HGCO=home_git_add_and_commit

# TODO:
# branches: une par machine (sur eana j'ai par exemple
# quelques logiciels installés (utilisables) seulement là)
# Il y a aussi les logiciels avec des préférences ou des
# credentials... à voir...
# Le fichier .xsession ...
# Les scripts utiles dans bin/
# Ma photo !

# TODO : mode intéractif très proche de l'utilisateur
# => installation sur une nouvelle machine
#    cloner la repo home_git, créer le lien symbolique
#    dans le PATH, cloner la repo HOME_GIT, choisir
#    une branche pour la mise à jour
#
# => mis à jour depuis la repos

unset u
